Project Plan

Map the current html2canvas pipeline end-to-end (capture triggers, throttling, perf metrics, image upload) so we know everything the new path must replicate.
Design a GPU scene system that mirrors DOM layout: command schema, diff strategy, text rendering approach, resource lifetime, and integration points with Svelte.
Build incremental prototypes (scene composer, renderer backends) and migrate UI slices one at a time, keeping DOM for semantics while verifying pixel parity.
Gradually retire capture.ts and related logic (throttling, health metrics) once new pipeline drives the CRT shader everywhere.
Add observability (frame timings, visual diffs) and fallback handling so CSS mode remains a safe escape hatch.
Sequential Prompts

1“Trace how createDomCapture is wired through CRTPostFX.svelte, listing every touchpoint (events, throttling, perf accounting) so we know what must be replaced.”

2“Document everything capture.ts currently does (html2canvas options, dirty-region tracking, ImageBitmap creation) and flag dependencies elsewhere in the codebase.”

3“Research UI primitives rendered on the CRT surface-inventory component styles, text needs, media-and propose the minimum draw-command schema to cover them.”

4“Draft the architecture for a GPU scene composer: data structures, diff/update flow from Svelte components, resource ownership, and interaction with event proxy.”

5“Design the text rendering strategy (e.g., MSDF atlas generation, kerning support) and outline how glyph data flows into the scene composer each frame.”

6“Create scaffolding for a SceneComposer module plus a WebGPU scene renderer that draws a test grid into an offscreen texture shared with the CRT shader.”

7“Add a WebGL2 fallback renderer following the same interface as the WebGPU version, ensuring both can render the test scene into a shared texture.”

8“Refactor CRTPostFX.svelte to initialise the scene renderer instead of html2canvas capture, keeping CSS mode as a fallback and plumbing the new texture into the CRT shader.”

9“Migrate one representative UI component (e.g., LinksApp layout) to feed draw commands into the scene composer, and build a visual diff harness to compare DOM vs GPU output.”

10“Remove the legacy html2canvas path, clean up capture-related metrics, and expand automated/perf tests to cover the new two-pass pipeline end-to-end.”

[x] Trace how createDomCapture is wired through CRTPostFX.svelte... - touches: initializeGpu(create/update throttle), updateRenderState(pause/trigger), applyInternalScale(trigger), handlePointerActivity(throttle/trigger), handleCursorUpdate(trigger), handleResize(trigger), handleVisibility(pause/trigger), setupReduceMotion(throttle), teardownGpu(destroy), handleCapture(onCapture stats).





[x] Document everything capture.ts currently does (html2canvas options, dirty-region tracking, ImageBitmap creation) and flag dependencies elsewhere in the codebase. - notes: sets up MutationObserver + animation/transition/resize listeners to mark dirty regions, tracks partial rects vs full viewport with EXPAND_PADDING/MAX_PARTIAL_RATIO, manages capture throttle/backoff (CAPTURE_COOLDOWN_MULTIPLIER, MAX_DYNAMIC_THROTTLE), reuses an Offscreen/HTML canvas and drawImage to maintain a composited buffer, then creates ImageBitmap with premultiplied alpha for onCapture callback. Inputs: optional getScale hook, ignores elements via data-crt-postfx-ignore. Consumers: CRTPostFX.svelte imports createDomCapture, FLIP_Y_CAPTURE, CaptureStats, DomCaptureController.
[x] Research UI primitives rendered on the CRT surface and propose a minimal draw-command schema. - notes: Cards/panels rely on rounded translucent fills, borders, and inner shadows (src/components/LinksApp.svelte:358, src/components/LinksApp.svelte:389); avatars and taskbar icons need clipped image quads with border + drop shadow (src/components/LinksApp.svelte:251, src/components/Taskbar.svelte:352). Window/title controls mix solid + gradient fills, hover states, and backdrop blur (src/components/Window.svelte:621, src/components/Window.svelte:663), while taskbar trays reuse semi-transparent surfaces with blur (src/components/Taskbar.svelte:320, src/components/Taskbar.svelte:362). Typography spans wide letter-spacing, uppercase, and accent colors (src/components/LinksApp.svelte:360, src/components/Taskbar.svelte:395); iconography arrives as SVG paths via Iconify components (src/components/LinksApp.svelte:310, src/components/LinksApp.svelte:552). Overlays use mix-blend modes and animated transforms (src/components/CRTCurtain.svelte:218, src/components/LinksApp.svelte:70), plus patterned gradients (src/components/Window.svelte:663, src/components/CRTPostFX.svelte:1580). Iframe content still exists (src/components/IframeSandbox.svelte:202), implying a fallback layer. Suggested schema: Layer command (z-order, blend mode, optional clip); RoundedRect primitive supporting solid/linear gradient fills, stroke, drop/inner shadows, and backdrop blur flag; Image primitive with clip radius, border, and color modulation; TextRun primitive (font id, weight, letter spacing, shadow); VectorPath primitive for icon glyphs; PatternFill option for tiled gradients/grids; ExternalSurface pass-through for browser-managed iframes/live DOM until migrated.
[x] Draft architecture for GPU scene composer, diff flow, and event proxy handoff. - notes: SceneManager tracks layers keyed by DOM node id; each node registers a component adapter producing declarative draw nodes (`RoundedRect`, `TextRun`, `ImageQuad`, etc.) with style props. Diff loop collects invalidated nodes and rebuilds flat GPU buffers via a StageAssembler (static vs dynamic layers). ResourceCache owns atlases (MSDF glyphs, sprites) and emits upload ops for renderer. WebGPURenderer/WebGL2Renderer expose `commitScene(sceneUpdate)` to stream vertex/uniform data into the offscreen texture shared with the CRT sampler. Composer exposes `beginFrame()`, `updateNode(nodeId, blueprint)`, `removeNode(nodeId)`, `endFrame() -> SceneUpdate` consumed by the renderer. DOM components use a SceneContext to push updates on layout/style changes (hooked to ResizeObserver/MutationObserver). Existing `eventProxy` feeds pointer positions through the SceneManager for hit-testing and cursor state, while `ExternalSurface` nodes cover iframe/native fallbacks until replaced.
[x] Design text rendering pipeline for GPU scene composer. - notes: Use multi-channel signed distance field atlases per font weight (heading mono, body sans) pre-generated at build time for Latin, with runtime glyph baking for new codepoints. Glyph atlas managed by ResourceCache with LRU pages (e.g., 1024x1024 RGBA8) and per-glyph metrics (advance, offset, rect). SceneManager requests shaped glyph runs from a TextLayout service (Harfbuzz wasm or browser Canvas fallback) that outputs positioned glyph quads with kerning applied and optional letter spacing/uppercase transforms observed in LinksApp (src/components/LinksApp.svelte:360). Composer stores TextRun nodes containing: fontId, weight/style, size, line height, color, shadow, emphasis flags, and array of glyph instances (atlas page, UVs, offset, advance). During endFrame, StageAssembler uploads glyph instance buffers for batching by font+page; renderer shaders sample MSDF, apply screen-space smoothing, and support subpixel positioning, drop shadows, and outline glow (for CRT effects). Text updates triggered by content/size changes recompute layout incrementally; static runs cached until style or text changes. EventProxy hit testing consults glyph bounds for precise interactions (links/buttons). Fallback path for rich text (emoji, icons) routes to ImageQuad using Twemoji sheet until colored vector glyphs are supported.
[x] Create scaffolding for SceneComposer and WebGPU test renderer. - notes: Added scene graph types (`src/lib/crt/sceneTypes.ts`) and a `SceneComposer` class exposing begin/update/end frame semantics with upload budgeting (`src/lib/crt/sceneComposer.ts`). Implemented `WebGpuSceneRenderer` that initialises WebGPU, manages an offscreen render target, and draws a procedural grid test pattern while replaying queued uploads (`src/lib/crt/webgpuSceneRenderer.ts`). No integration yet; modules are ready for later wiring into CRT pipeline.
[x] Add WebGL2 fallback scene renderer matching test grid. - notes: Introduced `SceneWebGl2Renderer` scaffolding that initialises an offscreen RGBA8 framebuffer, compiles fullscreen grid shaders, and executes queued upload callbacks (src/lib/crt/sceneWebgl2Renderer.ts). Maintains original CRT WebGL renderer untouched.
[x] Refactor CRTPostFX.svelte to initialise the scene renderer instead of html2canvas capture, keeping CSS mode as a fallback and plumbing the new texture into the CRT shader. - notes: Added an opt-in scene pipeline gated by document dataset so WebGPU sessions build a SceneComposer + WebGpuSceneRenderer, bind its offscreen texture via the new bindSceneTexture hook on WebGpuRenderer, and render the procedural grid each frame. WebGL/CSS (or flag-off) still rely on html2canvas domCapture. Resize/teardown refresh the binding, and scene resources are destroyed on mode switches so existing fallbacks stay intact.
